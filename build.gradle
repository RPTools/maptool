import org.apache.tools.ant.filters.ReplaceTokens
import java.text.SimpleDateFormat
import org.ajoberstar.grgit.*
import org.gradle.api.tasks.JavaExec

buildscript {
	repositories {
		mavenCentral()
		jcenter()
		maven {
			url "https://plugins.gradle.org/m2/" 
		}
	}
	dependencies {
		classpath 'org.ajoberstar:gradle-git:0.11.2'
		classpath "de.gliderpilot.gradle.jnlp:gradle-jnlp-plugin:0.0.5"
		classpath "com.diffplug.gradle.spotless:spotless:1.3.3"
	}
}

configurations {
	osxTools
	ftpAntTask
}

configurations.all {
	resolutionStrategy {
		cacheChangingModulesFor 0, 'seconds'
	}
}


dependencies {
	osxTools 'com.oracle.appbundler:AppBundlerTask:1.0'
	
	ftpAntTask("org.apache.ant:ant-commons-net:1.9.4")
	{
		module("commons-net:commons-net:1.4.1") { dependencies "oro:oro:2.0.8:jar" }
	}
}

//Functions & Variables
ext.compileDate = new Date();
ext.yyyymmdd = (new SimpleDateFormat('yyyyMMDD')).format(ext.compileDate);
ext.repo = Grgit.open(project.file('.'))

//Gets the version name from the build file or gradle properties
def getVersionName() {
	if (project.hasProperty('buildVersion')) {
		return buildVersion
	} else {
		String vtxtVersionNo = file('build-resources/version.txt').text.trim()
		return vtxtVersionNo
	}
}

// Look for various properties and return defaults if not defined.
// (You should define the various local directories in your gradle.properties)
def getLocalProperty(property) {
	def result
	switch (property) {
		case 'jWrapperDir':
			if (project.hasProperty('jWrapperDir')) {
				result = jWrapperDir
			} else {
				result = rootDir.toString() + "/build-resources/jWrapper"
			}
			break
		case 'Windows32JRE':
			if (project.hasProperty('Windows32JRE')) {
				result = Windows32JRE
			} else {
				result = rootDir.toString() + "../JREs/windows32"
			}
			break
		case 'Windows64JRE':
			if (project.hasProperty('Windows64JRE')) {
				result = Windows64JRE
			} else {
				result = rootDir.toString() + "../JREs/windows64"
			}
			break
		case 'Linux32JRE':
			if (project.hasProperty('Linux32JRE')) {
				result = Linux32JRE
			} else {
				result = rootDir.toString() + "../JREs/linux32"
			}
			break
		case 'Linux64JRE':
			if (project.hasProperty('Linux64JRE')) {
				result = Linux64JRE
			} else {
				result = rootDir.toString() + "../JREs/linux64"
			}
			break
		case 'Mac64JRE':
			if (project.hasProperty('Mac64JRE')) {
				result = Mac64JRE
			} else {
				result = rootDir.toString() + "../JREs/mac64"
			}
			break
		default:
			result = ''
			break
	}
	
	return result
}

allprojects {
	repositories {
		mavenCentral()
		maven { url = 'http://maptool.craigs-stuff.net/repo/' }
		// maven { url = 'http://www.nerps.net/repo/' }
		mavenLocal()
	}

	group = 'net.rptools.maptool'
	version = getVersionName()
}


subprojects {
	apply plugin: 'java'
	apply plugin: 'findbugs'
	apply plugin: 'pmd'
	apply plugin: 'application'
	apply plugin: "com.diffplug.gradle.spotless"
	apply plugin: 'eclipse'

	sourceCompatibility = 1.8
	targetCompatibility = 1.8

	// Dont fail build if tests fail until tests are cleaned up
	test.ignoreFailures = true

	findbugs {
		ignoreFailures = true
		toolVersion = '3.0.0'
		effort = 'max'
		sourceSets = []  // Empty source set so it wont run during build/check
	}

	pmd {
		ignoreFailures = true
		sourceSets = []  // Empty source set so it wont run during tebuild/check
	}

	spotless {
		java { 
			//licenseHeaderFile	'../spotless.license.java'
			eclipseFormatFile	'../build-resources/eclipse.prefs.formatter.xml' 
		}
		
		format 'misc', {
			target '**/*.gradle', '**/*.md', '**/.gitignore'
	
			// spotless has built-in rules for the most basic formatting tasks
			trimTrailingWhitespace()
			indentWithTabs() // or spaces. Takes an integer argument if you don't like 4
		}
	}

}


project(':launcher') {
	mainClassName='net.rptools.maptool.launcher.MapToolLauncher'
	ext.distSource = projectDir.getPath() + '/src/dist/'

	dependencies {
		compile 'commons-configuration:commons-configuration:1.10'
		compile 'commons-cli:commons-cli:1.3'
		compile files('../build-resources/jWrapper/jwrapperlib/jwrapper_utils.jar')

		testCompile group: 'junit', name: 'junit', version: '4.11'
	}

	jar {
		manifest.attributes(
				'Main-Class': mainClassName,
				)
	}

	processResources {
		from(sourceSets.main.resources.srcDirs) {
			include '**/*.properties'
			filter(ReplaceTokens, tokens: [
				'buildDate': rootProject.ext.yyyymmdd,  'buildNumber': getVersionName()])
		}
		from(sourceSets.main.resources.srcDirs) {
			exclude '**/*.properties'
		}
	}

	task release(dependsOn: assemble) << {
	}

	// create a single Jar with all dependencies
	task fatJar(type: Jar) {
		classifier 'fat'
		manifest {
			attributes 'Implementation-Title': 'MapTool-Launcher',
			'Implementation-Version': version,
			'Built-By': System.getProperty('user.name'),
			'Built-Date': new Date(),
			'Built-JDK': System.getProperty('java.version'),
			'Source-Compatibility': project.sourceCompatibility,
			'Target-Compatibility': project.targetCompatibility,
			'Main-Class': project.mainClassName
		}

		baseName = 'MapTool-Launcher'
		from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
		with jar
	}

	task deleteBuild(type: Delete) { delete 'build/' }
}

project(':maptool') {
	apply plugin: 'de.gliderpilot.jnlp'
	mainClassName='net.rptools.maptool.client.LaunchInstructions'
	ext.distSource = projectDir.getPath() + '/src/dist/'

	dependencies {
		compile 'net.java.abeille:abeille-formsrt:2.0'
		compile 'net.rptools.clientserver:clientserver:1.4.0.+'
		compile 'org.hibernate:antlr:2.7.5H3'
		compile 'commons-beanutils:commons-beanutils-core:1.8.3'
		compile 'org.ow2.util.bundles:commons-collections-3.2.1:1.0.0'
		compile 'commons-io:commons-io:2.4'
		compile 'commons-jxpath:commons-jxpath:1.3'
		compile 'commons-lang:commons-lang:2.6'
		compile 'commons-logging:commons-logging:1.1.1'
		compile 'commons-net:commons-net:3.2'
		compile 'commons-cli:commons-cli:1.3'
		compile 'net.rptools.decktool:decktool:1.0.b1'
		compile 'net.rptools.dicelib:dicelib:1.4.0.+'
		compile 'net.sf.ezmorph:ezmorph:1.0.5'
		compile 'com.caucho.hessian:hessian:3.1.6'
		compile 'jide-common:jide-common:3.2.3'
		compile 'jide-components:jide-components:3.2.3'
		compile 'jide-dialogs:jide-dialogs:3.2.3'
		compile 'jide-dock:jide-dock:3.2.3'
		compile 'jide-editor:jide-editor:3.2.3'
		compile 'jide-grids:jide-grids:3.2.3'
		compile 'jide-properties:jide-properties:3.2.3'
		compile 'jide-shortcut:jide-shortcut:3.2.3'
		compile 'de.huxhorn.sulky:de.huxhorn.sulky.3rdparty.jlayer:1.0'
		compile 'rhino:js:1.7R1'
		compile 'net.sf.json-lib:json-lib:2.4:jdk15'
		compile 'log4j:log4j:1.2.16'
		compile 'net.rptools.maptool.resource:maptool.resource:1.0.b18'
		compile 'net.rptools.parser:parser:1.4.0.+'
		compile 'ca.odell.renderpack:renderpack:1.2004'
		compile 'net.rptools.rplib:rplib:1.4.1.+'
		compile 'net.tsc.servicediscovery:servicediscovery:1.0.b5'
		compile 'org.swinglabs:swing-worker:1.1'
		compile 'net.sbbi.upnp:upnplib:1.0.9-nodebug'
		compile 'com.withay:withay-util:1.0'
		compile 'xmlpull:xmlpull:1.1.3.1'
		compile 'xpp3:xpp3_min:1.1.4c'
		compile 'com.thoughtworks.xstream:xstream:1.4.1'
		compile 'yasb:yasb:0.2-21012007'
		compile 'de.muntjak.tinylookandfeel:tinylaf-nocp:1.4.0'
		compile 'org.eclipse.jetty:jetty-server:9.3.0.M0'
		compile 'org.eclipse.jetty:jetty-servlet:9.3.0.M0'
		compile 'org.eclipse.jetty:jetty-webapp:9.3.0.M0'
		compile 'org.eclipse.jetty:jetty-continuation:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-server:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-client:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-servlet:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-api:9.3.0.M1'
		compile 'org.reflections:reflections:0.9.10'


		testCompile group: 'junit', name: 'junit', version: '4.11'
	}

	processResources {
		from(sourceSets.main.resources.srcDirs) {
			include '**/*.txt'
			filter(ReplaceTokens, tokens: [
				'buildDate': rootProject.ext.yyyymmdd,  'buildNumber': getVersionName()])
		}
		from(sourceSets.main.resources.srcDirs) {
			exclude '**/*.txt'
		}
	}


	task copyLibs(type: Sync) {
		description = "Copy the library files over to /lib"
		group = "Distribution"
		from configurations.compile
		into jar.destinationDir.getPath() + '/lib'
	}

	// Create the JAR
	jar {
		manifest.attributes(
			'Main-Class': mainClassName,
			'Class-Path': configurations.runtime.files.collect { "lib/" + it.name }.join(' ')
		)
	}
	assemble.dependsOn += copyLibs;

	task release(dependsOn: build) << {
	}

	jnlp {
		withXml {
			information {
				title 'RPTools MapTool'
				vendor project.group ?: project.name
			}
			security {
				'all-permissions'()
			}
		}
		signJarParams = [
			storepass: 'rptools',
			keystore: '../build-resources/rptools-keystore',
			alias: 'rptools',
			lazy: 'true'
		]
	}

	// create a single Jar with all dependencies
	task fatJar(type: Jar) {
		classifier 'fat'
		manifest {
			attributes 'Implementation-Title': 'MapTool',
			'Implementation-Version': version,
			'Built-By': System.getProperty('user.name'),
			'Built-Date': new Date(),
			'Built-JDK': System.getProperty('java.version'),
			'Source-Compatibility': project.sourceCompatibility,
			'Target-Compatibility': project.targetCompatibility,
			'Main-Class': project.mainClassName
		}
		baseName = 'MapTool'
		from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
		with jar
	}
	
	task deleteBuild(type: Delete) { delete 'build/' }
	
	// Add access rule to classpath for nashorn api
	// Note: This appends the following node to the JRE container classpathentry but only for Java 1.8 in case you are testing some other Java version
	// <accessrules><accessrule kind="accessible" pattern="jdk/nashorn/api/**"/></accessrules>
	eclipse.classpath.file {
		whenMerged {
			withXml { classpathXml ->
				def classpathXmlNode = classpathXml.asNode()
				Node classpathJreNode = node.find {it.@kind == 'con' && it.@path.contains('JRE_CONTAINER') && it.@path.contains('JavaSE-1.8')}
				// Only append if node is not null, eg it found the proper node entry.
				if(classpathJreNode) {
					classpathJreNode.appendNode('accessrules').appendNode('accessrule', [kind: 'accessible', pattern: 'jdk/nashorn/api/**'])
				}
			}
		}
	}
}



/*
 * Global Gradle Tasks
 */

// Shows project build version
task showBuildVersion << {
	description = "Shows project build version"
	group = "Information"

	println 'Build Version Number = ' + project.version
}

// Generates gradle wrapper
task wrapper(type: Wrapper) {
	description = "Updates Gradle wrapper."
	group = "Distribution"
	gradleVersion='2.12'
}

task copySubProjectFiles(type: Sync) {
	from project(':maptool').jar.destinationDir.getPath()
	from project(':maptool').ext.distSource
	from project(':launcher').jar.destinationDir.getPath()
	from project(':launcher').ext.distSource
	into 'build/tmp/dist/'
	outputs.upToDateWhen {
		false
	}
}
copySubProjectFiles.mustRunAfter(':maptool:release', ':launcher:release')


/**
 * The following tasks are used to create the Fat Jar distribution as well as
 * creating the jWrapper XML & mt.cfg from templates.
 * 
 * Task: publishRelease will create fresh jars and jWrapper build, then FTP
 * to server (currently for nerps.net.
 */
task createFatJars(dependsOn: ['maptool:deleteBuild', 'launcher:deleteBuild', 'launcher:fatJar', 'maptool:fatJar']) {
	description = "Generates a MapTool Fat Jars for distribution."
	group = "Distribution"
	doLast {
		println 'Creating MapTool Fat Jars...'
	}
}

task deleteJwrapperConfig(type: Delete) {
	description = "Delete the generated jwrapper.xml file"
	delete "${rootDir}/build-resources/jWrapper/jwrapper.xml"

	doLast {
		println "Deleting ${rootDir}/build-resources/jWrapper/jwrapper.xml"
	}
}

task deleteMtConfig(type: Delete) {
	description = "Delete the generated mt.cfg file"
	delete "${rootDir}/launcher/src/main/resources/net/rptools/maptool/launcher/config/mt.cfg"
	
	doLast {
		println "Deleting ${rootDir}/launcher/src/main/resources/net/rptools/maptool/launcher/config/mt.cfg"
	}
}

task createJwrapperConfig(dependsOn:deleteJwrapperConfig, type: Copy) {
	description = "Generates jWrapper XML config from template"
	group = "Distribution"
	
	from ('build-resources/jWrapper') {
		include 'jwrapper-template.xml'
		filter(ReplaceTokens, tokens: [
			'buildDate': rootProject.ext.yyyymmdd,
			'buildVersion': getVersionName(),
			'jWrapperDir': getLocalProperty('jWrapperDir'),
			'Linux32JRE': getLocalProperty('Linux32JRE'),
			'Linux64JRE': getLocalProperty('Linux64JRE'),
			'Windows32JRE': getLocalProperty('Windows32JRE'),
			'Windows64JRE': getLocalProperty('Windows64JRE'),
			'Mac64JRE': getLocalProperty('Mac64JRE'),
			'rootDir': rootDir.toString()])
	}
	into 'build-resources/jWrapper'
	rename { String fileName ->
		fileName.replace('-template', '')
	}
	
	doLast {
		println 'Setting jWrapper directory to: ' + "${rootDir}/build-resources/jWrapper"
	}
}

task createLaunchPropertiesFile(dependsOn:deleteMtConfig, type: Copy) {
	description = "Generates a MapTool default mt.cfg for package release using jWrapper"
	group = "Distribution"
	
	from ('build-resources/jWrapper') {
		include 'launch-template.properties'
		filter(ReplaceTokens, tokens: [
			'buildDate': rootProject.ext.yyyymmdd,  'buildVersion': getVersionName()])
	}
	into 'launcher/src/main/resources/net/rptools/maptool/launcher/config'
	rename { String fileName ->
		fileName.replace('-template', '')
	}
}

task createJwrapperRelease(dependsOn: ['createLaunchPropertiesFile', 'createFatJars', 'createJwrapperConfig'], type:JavaExec) {
	description = "Generates a MapTool release using jWrapper"
	group = "Distribution"
	workingDir = 'build-resources/jWrapper'
	
	main  = 'jwrapper.launch.JWCompiler'
	classpath = files("build-resources/jWrapper/jwrapper-00041197800.jar")
	args('jwrapper.xml')
	
	doLast {
		println 'Creating MapTool jWrapper Release in: ' + workingDir
	}
}

task ftpUpdateRelease {
	description = "Uploads jWrapper build to remote server"
	group = "Distribution"

	doLast {
		println "Uploading via FTP..."
		println "To remote server: " + ftpServer
		println "Remote directory: " + ftpRemoteDir
	
		ant {
			taskdef(name: 'ftp',
			classname: 'org.apache.tools.ant.taskdefs.optional.net.FTP',
			classpath: configurations.ftpAntTask.asPath)
			ftp(server: ftpServer, port: ftpPort, userid: ftpUserID, password: ftpPassword, remoteDir: ftpRemoteDir, passive: 'yes', verbose: true)
			{ fileset(file: "build-resources/jWrapper/JWrapperBuild/MapTool-*") }
		}
	}
}

task publishRelease(dependsOn: ['createJwrapperRelease', 'ftpUpdateRelease']) {
	description = "Generates jWrapper Release and Uploads to remote server."
	group = "Distribution"
	doLast{
		println 'Publish MapTool version ' + version + ' to maptool.nerps.net'
	}
}



//Deprecated: Use new Fat JAR & jWrapper build tasks.
task zipRelease(dependsOn: copySubProjectFiles, type: Zip) {
	from 'build/tmp/dist/'
	into  ''
	baseName = 'maptool-' + getVersionName()
	destinationDir new File(projectDir, 'build')
	outputs.upToDateWhen {
		false
	}
}

task osxApp() << {
	def baseDir = '.'
	def buildVersion = rootProject.getVersionName()
	def mainClassName = project(":maptool").mainClassName
	def sourceDir = 'build/tmp/dist'
	ant {
		taskdef(
			name: 'bundleapp',
			classname: 'com.oracle.appbundler.AppBundlerTask',
			classpath: configurations.osxTools.asPath
		)
		bundleapp(
			outputdirectory: 'build/tmp/',
			name: 'MapTool-' + buildVersion,
			displayname: 'MapTool-' + buildVersion,
			identifier: 'net.rptools.maptool',
			mainclassname: mainClassName,
			signature: 'RPTM',
			icon: 'build-resources/maptool-icon.icns'
		) {
			classpath(dir: sourceDir) {
				include(name: '*.jar')
				include(name: '**/*.jar')
			}
			option(value: '-Dapple.laf-useScreenMenuBar=true')
			option(value: '-Dfile.encoding=UTF-8')
			option(value: '-Xmx768m')
			option(value: '-Xss4m')
			option(value: '-Dcom.apple.textantialiasing=true')
			option(value: '-Dcom.apple.antialiasing=true')
			option(value: '-Djava.library.path=$APP_ROOT/Contents/Java')
		}
	}
}
osxApp.mustRunAfter(copySubProjectFiles)

task zipOSXApp(dependsOn: osxApp, type: Zip) {
	from 'build/tmp/MapTool-' + getVersionName() + '.app'
	into  'MapTool-' + getVersionName() + '.app'
	baseName = 'maptool-' + getVersionName() + '-osx'
	destinationDir new File(projectDir, 'build')
	outputs.upToDateWhen {
		false
	}
}

task release() << {
	println 'Creating Release'
}
release.dependsOn += zipRelease
release.dependsOn += zipOSXApp
