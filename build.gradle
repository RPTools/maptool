// vi:set ts=4:
import org.apache.tools.ant.filters.ReplaceTokens
import java.text.SimpleDateFormat
import org.ajoberstar.grgit.*
import org.gradle.api.tasks.JavaExec

buildscript {
	repositories {
		mavenLocal()
		jcenter()
		mavenCentral()
		maven { url "https://plugins.gradle.org/m2/" }
	}
	dependencies {
		classpath 'org.ajoberstar:gradle-git:0.11.2'
		classpath "de.gliderpilot.gradle.jnlp:gradle-jnlp-plugin:0.0.5"
		classpath "com.diffplug.gradle.spotless:spotless:1.3.3"
	}
}
defaultTasks 'clean', 'build'

configurations {
	osxTools
	ftpAntTask
}

configurations.all {
	resolutionStrategy {
		cacheChangingModulesFor 0, 'seconds'
	}
}


dependencies {
	osxTools 'com.oracle.appbundler:AppBundlerTask:1.0'

	ftpAntTask("org.apache.ant:ant-commons-net:1.9.4") {
		module("commons-net:commons-net:1.4.1") {
			dependencies "oro:oro:2.0.8:jar"
		}
	}
}

ext {
    //Functions & Variables
    vendor = 'RPTools'
    javafx = false
    // These should be figured out dynamically by looking at
    // 'java.platform'
    String os = System.getProperty("os.name").toLowerCase()
    macos = os.contains("mac os x")
    windows = os.contains("windows")
    linux = !macos && !windows

    yyyymmdd = (new SimpleDateFormat('yyyyMMdd')).format(new Date());
    repo = Grgit.open(project.file('.'))
}

//Gets the version name from the build file or gradle properties
def getVersionName() {
	if (project.hasProperty('buildVersion')) {
		return buildVersion
	} else {
		String vtxt = file('build-resources/version.txt').text.trim()
		return vtxt
	}
}

// Look for various properties and return defaults if not defined.  (You
// should define the various local directories in your
// gradle.properties)
def getLocalProperty(property) {
	def result
	switch (property) {
		case 'jWrapperDir':
			if (project.hasProperty('jWrapperDir')) {
				result = jWrapperDir
			} else {
				result = rootDir.toString() + "/build-resources/jWrapper"
			}
			break
		case 'releaseDir':
			if (project.hasProperty('releaseDir')) {
				result = releaseDir
			} else {
				result = rootDir.toString() + "/build/release"
			}
			break
		case 'Windows32JRE':
			if (project.hasProperty('Windows32JRE')) {
				result = Windows32JRE
			} else {
				result = rootDir.toString() + "../JREs/windows32"
			}
			break
		case 'Windows64JRE':
			if (project.hasProperty('Windows64JRE')) {
				result = Windows64JRE
			} else {
				result = rootDir.toString() + "../JREs/windows64"
			}
			break
		case 'Linux32JRE':
			if (project.hasProperty('Linux32JRE')) {
				result = Linux32JRE
			} else {
				result = rootDir.toString() + "../JREs/linux32"
			}
			break
		case 'Linux64JRE':
			if (project.hasProperty('Linux64JRE')) {
				result = Linux64JRE
			} else {
				result = rootDir.toString() + "../JREs/linux64"
			}
			break
		case 'Mac64JRE':
			if (project.hasProperty('Mac64JRE')) {
				result = Mac64JRE
			} else {
				result = rootDir.toString() + "../JREs/mac64"
			}
			break
		default:
			result = ''
			break
	}

	return result
}

allprojects {
	repositories {
		mavenLocal()
		jcenter()
		mavenCentral()
		maven { url 'http://maptool.craigs-stuff.net/repo/' }
	}
	group = 'net.rptools.maptool'
	version = getVersionName()
}

subprojects {
	apply plugin: 'base'
	apply plugin: 'java'
	apply plugin: 'findbugs'
	apply plugin: 'pmd'
	apply plugin: 'application'
	apply plugin: "com.diffplug.gradle.spotless"
	apply plugin: 'eclipse'

	sourceCompatibility = 1.9
	targetCompatibility = 1.9

	// Don't fail build if tests fail until tests are cleaned up
	test.ignoreFailures = true

	findbugs {
		ignoreFailures = true
		toolVersion = '3.0.0'
		effort = 'max'
		sourceSets = []  // Empty source set so it wont run during build/check
	}

	pmd {
		ignoreFailures = true
		sourceSets = []  // Empty source set so it wont run during build/check
	}

	spotless {
		java {
			//licenseHeaderFile	'../spotless.license.java'
			eclipseFormatFile	'../build-resources/eclipse.prefs.formatter.xml'
		}

		format 'misc', {
			target '**/*.gradle', '**/*.md', '**/.gitignore'

            // spotless has reasonable defaults for most file types
			trimTrailingWhitespace()
			indentWithSpaces(4) // Number of spaces to indent
		}
	}
}

project(':launcher') {
	mainClassName = 'net.rptools.maptool.launcher.MapToolLauncher'
    applicationName = 'Launcher'
    version = getVersionName()

    String appDescription = 'Launcher for MapTool'
	ext.distSource = projectDir.getPath() + '/src/dist/'

	dependencies {
		compile 'commons-configuration:commons-configuration:1.10'
		compile 'commons-cli:commons-cli:1.3'
		testCompile 'junit:junit:4.12'
	}

	jar {
		manifest.attributes(
			'Main-Class': mainClassName,
		)
	}

	processResources {
		from(sourceSets.main.resources.srcDirs) {
			include '**/*.properties'
			filter(ReplaceTokens, tokens: [
				'buildDate': rootProject.ext.yyyymmdd,
				'buildNumber': version]
			)
		}

		from(sourceSets.main.resources.srcDirs) {
			exclude '**/*.properties'
		}

		copy{
			from ('build-resources/config') {
				include 'launch-template.properties'
				filter(ReplaceTokens, tokens: [
					'buildDate': rootProject.ext.yyyymmdd,
					'buildVersion': version]
				)
			}
			into 'src/main/resources/net/rptools/maptool/launcher/config'
			rename { String fileName ->
				fileName.replace('-template', '')
			}
			outputs.upToDateWhen {
				false
			}
		}
	}

	// create a single Jar with all dependencies
	task fatJar(type: Jar) {
		// This is wrong.  Calling this task should be done in the
		// 'processResources' task of this project, but I still need
		// to learn how to do that.  I know it's a Good Thing tho,
		// since the output from gradle tells me that it notices the
		// change to the file and reruns that other task again.
		classifier 'fat'
		manifest {
			attributes 'Implementation-Title': applicationName,
                'Implementation-Version': version,
                'Built-By': System.getProperty('user.name'),
                'Built-Date': new Date(),
                'Built-JDK': System.getProperty('java.version'),
                'Source-Compatibility': project.sourceCompatibility,
                'Target-Compatibility': project.targetCompatibility,
                'Main-Class': project.mainClassName
		}
		baseName = applicationName
		from {
			configurations.compile.collect {
				it.isDirectory() ? it : zipTree(it)
			}
		}
		with jar
	}

    // Currently includes license, manifest (for hiDPI)
    // and msvcr100.dll (due to packaging bug)
    task copyPackageExtras(type: Copy) {
        from('package/license/')
        into(libsDir) // ('build/libs/')
        include 'COPYING.AFFERO'
        outputs.upToDateWhen { false }
    }

    task prepareInnoSetup(type: Copy) {
        from("package/windows/Launcher.iss.template")
        into("package/windows/")
        rename("Launcher.iss.template", "Launcher.iss")
        def tokens = [
            AppName: "${applicationName}",
            AppVersion: "${version}",
            Vendor: "${vendor}",
            WizardImage: "${project.projectDir.absolutePath}/"
                + "package/windows/${applicationName}-setup.bmp",
            Slash: "\\",
        ]
        expand(tokens)
        inputs.properties(tokens)
        outputs.upToDateWhen { false }
    }

	task release(dependsOn: [assemble, fatJar]) {
        // no-op; just used for dependency purposes
	}

    task deploy(dependsOn: [release, copyPackageExtras]) {
        group = 'distribution'
        description = 'Create native installers'

        doLast {
            // These only apply to Windows
            if (windows) {
                prepareInnoSetup()
            }
            // These only apply to OSX
            if (macos) {
                // Old app must be deleted or packager fails with 'file
                // already exists' error.
                delete "build/distributions/${applicationName}.app"

                applicationDefaultJvmArgs = [
                    '-Dapple.laf.useScreenMenuBar=true',
                    '-Dfile.encoding=UTF-8',
                    '-Dcom.apple.textantialiasing=true',
                    '-Dcom.apple.antialiasing=true',
                ]
            }

            // Note: You can specify a JRE using
            //  "-Bruntime=../../../deploy-ready-jre"
            // It will bundle system/workspace JDK by default
            def javapackager_deploy = exec {
                workingDir "${project.projectDir.absolutePath}"

                println workingDir
                println "${vendor}:${applicationName}:${version}"

                commandLine "javapackager",
                    "-deploy",
                    "-v", // turns on verbose output
                    "-appclass", mainClassName,
                    "-description", appDescription,
                    "-name", applicationName,
                    // jnlp: .jnlp and .html for Java Web Start
                    // installer: all installers for current platform
                    // image (macOS): .app; (Windows/Linux): directory
                    // all: (same as 'installer' plus 'image')
                    // exe: Windows .exe
                    // msi: Windows installer package
                    // dmg: DMG for macOS
                    // pkg: PKG for macOS
                    // mac.appStore:
                    // rpm: Linux RPM package
                    // deb: Linux DEB package
                    "-native", "all",
                    // Don't attempt to sign generated bundles
                    "-nosign",
                    "-outdir", distsDir, // "build/distributions"
                    "-outfile", applicationName,
                    //"-paramfile", 'packages/macos/abcd.txt',
                    //"-opreloader", 'jfx.preloader.class',
                    "-srcdir", "build/libs",
                    "-srcfiles", "${applicationName}-${version}-fat.jar",
                    //"--strip-native-commands", "true",
                    // These are for 'jnlp' and specify how the HTML payload
                    // driver is constructed.
                    //"-templateId", "maptool",
                    //"-templateInFilename", "package/maptool.template",
                    //"-templateOutFilename", "package/maptool",
                    "-title", applicationName,
                    "-vendor", vendor,

                    // These options are passed to the bundler that
                    // generates the application artifact.  They may
                    // be specific to the bundler being used.

                    // These apply to all bundlers:
                    "-BappVersion=" + version,
                    // Directory is relative to 'package/<platform>'
                    "-BdropinResourcesRoot=.",
                    // Location of the default icon to be used:
                    // (Linux: 'png', macOS: 'icns', Windows: 'ico')
                    //"-Bicon=MyIcons",
                    "-Bidentifier=net.rptools.maptool",
                    //"-BjvmOptions=" + defaultJvmArgs,
                    // We want the MAPTOOL_DATADIR to be specified when
                    // the launcher is executed so that the value can be
                    // passed along to MapTool (and stored in the
                    // launcher's config file).  Otherwise, the launcher
                    // won't have access to the 'vendor' string...
                    "-BjvmProperties=MAPTOOL_DATADIR=.maptool-" + vendor,
                    //"-BuserJvmOptions=..."
                    //"-BpreferencesID=<node>",
                    "-BlicenseFile=COPYING.AFFERO",
                    "-BlicenseType=GNU AFFERO GENERAL PUBLIC LICENSE",
                    "-BsystemWide=false",

                    // These are specific to the macOS platform:
                    "-Bmac.CFBundleIdentifier=net.rptools.maptool.launcher",
                    //"-Bmac.CFBundleName=MapTool", // default is '-name'
                    "-Bmac.CFBundleVersion=1.4.1",
                    "-Bmac.category=Games",
                    //"-Bmac.signing-key-developer-id-app=<key>",
                    //"-Bmac.signing-key-developer-id-installer=<key>",
                    //"-Bmac.bundle-id-signing-prefix=<prefix>",

                    // These are specific to the Linux platform:
                    //"-Bcategory=Games",
                    //"-Bcopyright=AGPL/LGPL",
                    //"-Bemail=<debian_maintainer>",

                    // These are specific to the Windows platform:
                    "-BAssociations=cmpgn",
                    "-Bcategory=Games",
                    "-Bemail=http://forums.rptools.net/",
                    "-BinstalldirChooser=true",
                    "-BmenuHint=true",
                    "-BshortcutHint=true",
                    "-Bwin.menuGroup=" + vendor,
                    // Not documented?
                    "-Bwin.msi.productVersion=1.4.1",
                    // This is here so all lines above can end with commas
                    "-Bx=x"

                    println commandLine
            }
        }
    }
}

project(':maptool') {
	apply plugin: 'de.gliderpilot.jnlp'
	mainClassName='net.rptools.maptool.client.LaunchInstructions'
	ext.distSource = projectDir.getPath() + '/src/dist/'

	dependencies {
        // Our own library on bintray.  May be rolled into MT at some
        // point.
        compile 'net.rptools.rplib:rplib:1.4.1.7'

		compile 'net.java.abeille:abeille-formsrt:2.0'
		compile 'net.rptools.clientserver:clientserver:1.4.0.+'
		compile 'org.hibernate:antlr:2.7.5H3'
		compile 'commons-beanutils:commons-beanutils-core:1.8.3'
		compile 'org.ow2.util.bundles:commons-collections-3.2.1:1.0.0'
		compile 'commons-io:commons-io:2.4'
		compile 'commons-jxpath:commons-jxpath:1.3'
		compile 'commons-lang:commons-lang:2.6'
		compile 'commons-logging:commons-logging:1.1.1'
		compile 'commons-net:commons-net:3.2'
		compile 'commons-cli:commons-cli:1.3'
		compile 'net.rptools.decktool:decktool:1.0.b1'
		compile 'net.rptools.dicelib:dicelib:1.4.0.+'
		compile 'net.sf.ezmorph:ezmorph:1.0.5'
		compile 'com.caucho.hessian:hessian:3.1.6'
		compile 'jide-common:jide-common:3.2.3'
		compile 'jide-components:jide-components:3.2.3'
		compile 'jide-dialogs:jide-dialogs:3.2.3'
		compile 'jide-dock:jide-dock:3.2.3'
		compile 'jide-editor:jide-editor:3.2.3'
		compile 'jide-grids:jide-grids:3.2.3'
		compile 'jide-properties:jide-properties:3.2.3'
		compile 'jide-shortcut:jide-shortcut:3.2.3'
		compile 'de.huxhorn.sulky:de.huxhorn.sulky.3rdparty.jlayer:1.0'
		compile 'rhino:js:1.7R1'
		compile 'net.sf.json-lib:json-lib:2.4:jdk15'
		compile 'log4j:log4j:1.2.16'
		compile 'net.rptools.maptool.resource:maptool.resource:1.0.b18'
		compile 'net.rptools.parser:parser:1.4.0.+'
		compile 'ca.odell.renderpack:renderpack:1.2004'
		compile 'net.rptools.rplib:rplib:1.4.1.7+'
		compile 'net.tsc.servicediscovery:servicediscovery:1.0.b5'
		compile 'org.swinglabs:swing-worker:1.1'
		compile 'net.sbbi.upnp:upnplib:1.0.9-nodebug'
		compile 'com.withay:withay-util:1.0'
		compile 'xmlpull:xmlpull:1.1.3.1'
		compile 'xpp3:xpp3_min:1.1.4c'
		compile 'com.thoughtworks.xstream:xstream:1.4.9'
		compile 'yasb:yasb:0.2-21012007'
		compile 'de.muntjak.tinylookandfeel:tinylaf-nocp:1.4.0'
		compile 'org.eclipse.jetty:jetty-server:9.3.0.M0'
		compile 'org.eclipse.jetty:jetty-servlet:9.3.0.M0'
		compile 'org.eclipse.jetty:jetty-webapp:9.3.0.M0'
		compile 'org.eclipse.jetty:jetty-continuation:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-server:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-client:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-servlet:9.3.0.M1'
		compile 'org.eclipse.jetty.websocket:websocket-api:9.3.0.M1'
		compile 'org.reflections:reflections:0.9.10'

		testCompile 'junit:junit:4.12'
	}

	processResources {
		from(sourceSets.main.resources.srcDirs) {
			include '**/*.txt'
			filter(ReplaceTokens, tokens: [
				'buildDate': rootProject.ext.yyyymmdd,
				'buildNumber': getVersionName()
			])
		}
		from(sourceSets.main.resources.srcDirs) {
			exclude '**/*.txt'
		}
	}

	task copyLibs(type: Sync) {
		description = "Copy the library files over to /lib"
		group = "Distribution"
		from configurations.compile
		into jar.destinationDir.getPath() + '/lib'
	}

	// Create the JAR
	jar {
		manifest.attributes(
			'Main-Class': mainClassName,
			'Class-Path': configurations.runtime.files.collect {
				"lib/" + it.name
			}.join(' ')
		)
	}
	assemble.dependsOn += copyLibs;

	task release(dependsOn: build) << {
	}

	jnlp {
		withXml {
			information {
				title 'RPTools MapTool'
				vendor project.group ?: project.name
			}
			security {
				'all-permissions'()
			}
		}
		signJarParams = [
			storepass: 'rptools',
			keystore: '../build-resources/rptools-keystore',
			alias: 'rptools',
			lazy: 'true'
		]
	}

	// create a single Jar with all dependencies
	task fatJar(type: Jar) {
		classifier 'fat'
		manifest {
			attributes 'Implementation-Title': 'MapTool',
			'Implementation-Version': version,
			'Built-By': System.getProperty('user.name'),
			'Built-Date': new Date(),
			'Built-JDK': System.getProperty('java.version'),
			'Source-Compatibility': project.sourceCompatibility,
			'Target-Compatibility': project.targetCompatibility,
			'Main-Class': project.mainClassName
		}
		baseName = 'MapTool'
		from {
			configurations.compile.collect {
				it.isDirectory() ? it : zipTree(it)
			}
		}
		with jar
	}

	task deleteBuild(type: Delete) {
		delete 'build/'
		outputs.upToDateWhen {
			false
		}
	}

	// Generates the splash screen JWrapper uses during install so
	// user see's the version Also creates a splash to use on web
	// page to show current version Lastly, it also creates a
	// MapTool-version.js which is just a javascript variable that
	// holds the version to use dynamically choose latest version to
	// download
	task createSplashImages(type: JavaExec) {
		description = "Generates splash screens"
		group = "Distribution"
		main = "net.rptools.maptool.util.CreateVersionedInstallSplash"
		classpath = sourceSets.main.runtimeClasspath

//		args '-version=' + getVersionName()
//		args '-output=' + getLocalProperty('jWrapperDir') + '/maptool_installing_splash.png'
//		args '-web_output=' + getLocalProperty('releaseDir') + '-' + getVersionName()
	}

	// Add access rule to classpath for nashorn api
	// Note: This appends the following node to the JRE container classpathentry but only for Java 1.8 in case you are testing some other Java version
	// <accessrules>
	//   <accessrule kind="accessible" pattern="jdk/nashorn/api/**"/>
	// </accessrules>
	eclipse.classpath.file {
		whenMerged {
			withXml { classpathXml ->
				def classpathXmlNode = classpathXml.asNode()
				Node classpathJreNode = node.find {
					it.@kind == 'con' &&
					it.@path.contains('JRE_CONTAINER') &&
					(it.@path.contains('JavaSE-1.8') ||
					 it.@path.contains('JavaSE-9'))
				}
				// Only append if node is not null, eg
				// if it found the proper node entry.
				if (classpathJreNode) {
					classpathJreNode
						.appendNode('accessrules')
						.appendNode('accessrule', [
							kind: 'accessible',
							pattern: 'jdk/nashorn/api/**'
						])
				}
			}
		}
	}
}

/*
 * Global Gradle Tasks
 */

// Shows project build version
task showBuildVersion << {
	description = "Shows project build version"
	group = "Information"

	println 'Build Version Number = ' + project.version
}

// Generates gradle wrapper
task wrapper(type: Wrapper) {
	description = "Updates Gradle wrapper."
	group = "Distribution"
	gradleVersion='4.5.1'
}

task copySubProjectFiles(type: Sync) {
	from project(':maptool').jar.destinationDir.getPath()
	from project(':maptool').ext.distSource
	from project(':launcher').jar.destinationDir.getPath()
	from project(':launcher').ext.distSource
	into 'build/tmp/dist/'
	outputs.upToDateWhen {
		false
	}
}
copySubProjectFiles.mustRunAfter(':maptool:release', ':launcher:release')


/**
 * The following tasks are used to create the Fat Jar distribution as
 * well as creating the launch.properties from templates.
 *
 * Task: publishRelease will create fresh jars and jWrapper build, then
 * FTP to server (currently for nerps.net).
 */
task createFatJars(dependsOn: [
        'maptool:deleteBuild',
        'launcher:deleteBuild',
        'maptool:fatJar',
        'launcher:fatJar',
    ]) {
	description = "Generates MapTool and Launcher Fat Jars for distribution."
	group = "Distribution"
	doLast {
		println 'Creating MapTool and Launcher Fat Jars...'
	}
}

task deleteLaunchProperties(type: Delete) {
	description = "Delete the generated launch.properties file"
	delete "${rootDir}/launcher/src/main/resources/net/rptools/maptool/launcher/config/launch.properties"

	doLast {
		println "Deleting ${rootDir}/launcher/src/main/resources/net/rptools/maptool/launcher/config/launch.properties"
	}
}

task osxApp() {
    doLast {
        def baseDir = '.'
        def buildVersion = rootProject.getVersionName()
        def mainClassName = project(":maptool").mainClassName
        def sourceDir = 'build/tmp/dist'
        ant {
            taskdef(
                name: 'bundleapp',
                classname: 'com.oracle.appbundler.AppBundlerTask',
                classpath: configurations.osxTools.asPath
            )
            bundleapp(
                outputdirectory: 'build/tmp/',
                name: 'MapTool-' + buildVersion,
                displayname: 'MapTool-' + buildVersion,
                identifier: 'net.rptools.maptool',
                mainclassname: mainClassName,
                signature: 'RPTM',
                icon: 'build-resources/maptool-icon.icns'
            ) {
                classpath(dir: sourceDir) {
                    include(name: '*.jar')
                    include(name: '**/*.jar')
                }
                option(value: '-Dapple.laf.useScreenMenuBar=true')
                option(value: '-Dfile.encoding=UTF-8')
                option(value: '-Xmx768m')
                option(value: '-Xss4m')
                option(value: '-Dcom.apple.textantialiasing=true')
                option(value: '-Dcom.apple.antialiasing=true')
                option(value: '-Djava.library.path=$APP_ROOT/Contents/Java')
            }
        }
    }
}
osxApp.mustRunAfter(copySubProjectFiles)

task release() {
    doLast {
        println 'Creating Release'
    }
}
//release.dependsOn += launcher.release
//release.dependsOn += maptool.release
