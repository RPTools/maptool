/*
 * This software copyright by various authors including the RPTools.net
 * development team, and licensed under the LGPL Version 3 or, at your option,
 * any later version.
 *
 * Portions of this software were originally covered under the Apache Software
 * License, Version 1.1 or Version 2.0.
 *
 * See the file LICENSE elsewhere in this distribution for license details.
 */

package net.rptools.maptool.client.ui.token;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.TexturePaint;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import javax.swing.JPanel;
import net.rptools.lib.swing.SwingUtil;
import net.rptools.maptool.client.AppStyle;
import net.rptools.maptool.client.MapTool;
import net.rptools.maptool.model.Token;
import net.rptools.maptool.model.Zone;
import net.rptools.maptool.model.Token.TokenShape;
import net.rptools.maptool.util.ImageManager;

public class TokenVblPanel extends JPanel {
	private Token token;
	private Area tokenVBL;
	private boolean hideTokenImage = false;
	private boolean autoGenerated = false;
	private int alphaSensitivity = 1;

	public TokenVblPanel() {
		addMouseWheelListener(new MouseWheelListener() {
			public void mouseWheelMoved(MouseWheelEvent e) {
				// Not for snap-to-scale
				if (!token.isSnapToScale()) {
					return;
				}
				//double delta = e.getWheelRotation() > 0 ? -.1 : .1;
				//double scale = token.getSizeScale() + delta;

				// Range
				//scale = Math.max(.1, scale);
				//scale = Math.min(3, scale);
				//token.setSizeScale(scale);
				repaint();
			}
		});
		addMouseListener(new MouseAdapter() {
			String old;

			@Override
			public void mousePressed(MouseEvent e) {
			}

			public void mouseReleased(MouseEvent e) {
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				old = MapTool.getFrame().getStatusMessage();
				//MapTool.getFrame().setStatusMessage("Mouse Wheel to zoom; double-LClick to reset position and zoom");
			}

			@Override
			public void mouseExited(MouseEvent e) {
				//				if (old != null)
				//					//MapTool.getFrame().setStatusMessage(old);
			}

			@Override
			public void mouseClicked(MouseEvent e) {
			}
		});
		addMouseMotionListener(new MouseMotionAdapter() {
			@Override
			public void mouseDragged(MouseEvent e) {
			}
		});
	}

	public double getSizeScale() {
		return token.getSizeScale();
	}

	public int getAnchorX() {
		return token.getAnchor().x;
	}

	public int getAnchorY() {
		return token.getAnchor().y;
	}

	public void setToken(Token token) {
		this.token = new Token(token);
		setTokenVBL(token.getVBL());
		if (token.getAlphaSensitivity() >= 0)
			alphaSensitivity = token.getAlphaSensitivity();
	}

	public Token getToken() {
		return token;
	}

	public Area getTokenVBL() {
		return tokenVBL;
	}

	public void setTokenVBL(Area tokenVBL) {
		this.tokenVBL = tokenVBL;
	}

	public boolean isHideTokenImage() {
		return hideTokenImage;
	}

	public void setHideTokenImage(boolean hideTokenImage) {
		this.hideTokenImage = hideTokenImage;
	}

	public void setAutoGenerated(boolean autoGenerated) {
		this.autoGenerated = autoGenerated;
	}

	public boolean getAutoGenerated() {
		return autoGenerated;
	}

	public int getAlphaSensitivity() {
		return alphaSensitivity;
	}

	public void setAlphaSensitivity(int value) {
		alphaSensitivity = value;
	}

	@Override
	protected void paintComponent(Graphics g) {
		Dimension panelSize = getSize();
		Dimension panelUsableSize = new Dimension((int) Math.round(panelSize.width * .8), (int) Math.round(panelSize.height * .8));

		Zone zone = MapTool.getFrame().getCurrentZoneRenderer().getZone();

		// Gather info
		BufferedImage image = ImageManager.getImage(token.getImageAssetId());
		java.awt.Rectangle tokenSize = token.getBounds(zone);
		Dimension originalImgSize = new Dimension(image.getWidth(), image.getHeight());
		Dimension imgSize = new Dimension(image.getWidth(), image.getHeight());

		// If figure we need to calculate an additional offset for the token height
		double iso_ho = 0;
		if (token.getShape() == TokenShape.FIGURE) {
			double th = token.getHeight() * Double.valueOf(tokenSize.width) / token.getWidth();
			iso_ho = tokenSize.height - th;
			tokenSize = new java.awt.Rectangle(tokenSize.x, tokenSize.y - (int) iso_ho, tokenSize.width, (int) th);
		}

		SwingUtil.constrainTo(imgSize, panelUsableSize.width, panelUsableSize.height);
		Point centerPoint = new Point(panelSize.width / 2, panelSize.height / 2);
		Graphics2D g2d = (Graphics2D) g;

		// Background
		((Graphics2D) g).setPaint(new TexturePaint(AppStyle.squaresTexture, new java.awt.Rectangle(0, 0, AppStyle.squaresTexture.getWidth() * 2, AppStyle.squaresTexture.getHeight() * 2)));
		g2d.fillRect(0, 0, panelSize.width, panelSize.height);
		AppStyle.shadowBorder.paintWithin((Graphics2D) g, 0, 0, panelSize.width, panelSize.height);

		if (!isHideTokenImage()) {
			g2d.drawImage(image, centerPoint.x - imgSize.width / 2 + token.getAnchor().x, centerPoint.y - imgSize.height / 2 + token.getAnchor().y, imgSize.width, imgSize.height, this);
		}

		// Draw the VBL
		if (tokenVBL != null) {
			double tx = centerPoint.x - (imgSize.getWidth() / 2);
			double ty = centerPoint.y - (imgSize.getHeight() / 2);
			double sx = imgSize.getWidth() / originalImgSize.getWidth();
			double sy = imgSize.getHeight() / originalImgSize.getHeight();

			AffineTransform atArea = AffineTransform.getTranslateInstance(tx, ty);
			atArea.concatenate(AffineTransform.getScaleInstance(sx, sy));

			g2d.setColor(AppStyle.tokenTopologyColor);
			g2d.fill(atArea.createTransformedShape(tokenVBL));
		}
	}
}
